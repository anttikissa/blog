# A markdown killer

In this post, we'll create an easier way to write the posts.

We might use a readymade markup language such as Markdown or Textile, but for
the sake of exercise we'll implement one ourselves.  It can't be that hard, can
it?

Our markup language will resemble Markdown closely.  Some features won't be
supported because HTML will do just fine (like horizontal rules, images, line
breaks); others we won't implement because they're not needed yet (like
nested lists); and some will look totally different because I think they should
look like they look in the browser (`/italics/`, `*bold*`, `_links_`); 

Unlike Markdown, which supports several different ways to emphasize text or to
write links, we'll just support a single way of doing things -- just to keep
things simple.

I expect the first version to be at least a bit buggy and missing some features
we will eventually require.  We'll revisit these shortcomings later.

## A wishlist for our markdown clone:

Paragraphs are separated by blank lines.  For simplicity, blank lines also
separate them from other elements, like lists, headings, and code blocks.

A line starting with `#`, `##`, etc. becomes a heading: `<h1>`, `<h2>`, etc.

HTML elements go through as-is (except when inside backtick quotes or code
blocks).  This includes top-level elements: a line starting with a HTML element
should start a top-level element, instead of being wrapped inside a `<p>`.

Backticks (`\``) create `<code>` elements, and backslashes (`\\`) quote
backticks, themselves, and other markup-specific characters.

The content in backticks and code blocks is escaped -- you can use `<` instead
of `&lt;` and `&` instead of `&` and so on.  But elsewhere they are considered
raw HTML.  We may have to also escape elsewhere, as the `&` is often used in
body text, and mathematical text might make heavy use of `<` and `>`.  But let's
not do that yet.

Code blocks are indented with 4 spaces.  Tabs are converted 4 spaces.  There
will be no tabs in the resulting HTML.  They behave just like `<code>` elements,
except being wrapped inside a `<pre>`.  A `*` in the beginning of a code block
line wraps that line inside a `<b>`.

One or more words can be set `/in italics/` (which generates a `<i>` tag), or
`*in bold*` (which generates a `<b>` tag).  For now, these must be surrounded by
whitespace so that they can be picked apart easily.  We'll see if can (or need
to) lift that restriction later.

Links are presented `_like this_ (http://url.to/link)`.  The underscores are not
necessary if the link starts with `http://` and if the link text consists of a
single word.  (The reason for being different from Markdown `[link text](link
url)` is that I'm simply not psychologically compatible with the Markdown
syntax.  It's as if `[]` and `()` somehow fall into the same category in my
brain and I never get them in the correct order.)

Unordered lists start with `* `.  Ordered lists start with `# `.  We won't
support nested list items until we need them (which might be "never").

Blockquotes are prefixed by `> `.  The contents of the blockquote will be
stripped off the `> ` prefix and then run through the markup filter; so
preformatted `<code>` blocks, multiple paragraphs, and other markup elements are
formatted as they are formatted outside blockquotes.

TODO figure out a good syntax for commenting out lines. `#` won't do since it's
a heading at the start of line; what will? `//`?  Except inside code blocks?

Finally, to make it easier to write &ndash; and &mdash, `--` is converted to
`&ndash;` and `---` to `&mdash;`.

## The first hints of modularity

We'll make Markdown Killer (the name of the markup language until someone comes
up with a better one) a module so it can be reused.  It goes to `lib/mk.js`:

	function mk(text) {
		// here goes the implementation
	}

	module.exports = mk;

In `server/run.js`, we use it:

	var fs = require('fs');
*	var mk = require('../lib/mk');
    
	var env = process.env.BLOG_ENV == 'dev' ? 'dev' : 'prod'

We decide to give the `.txt` extension to posts written in Markdown Killer, to
make it easier to tell them apart from raw HTML posts.  This requires some
changes in the code:

	var filenames = fs.readdirSync(__dirname + "/../posts");

*	var postFiles = filenames.filter(function(filename) {
*		return filename.match(/^\d+(\.txt)?$/);
*	}).map(function(filename) {
*		var match = filename.match(/^(\d+)(\.txt)?$/);
*		return {
*			id: match[1],
*			filename: filename,
*			type: match[2] == '.txt' ? 'mk' : 'html'
*		};
*	});

*	postFiles.sort(function(a, b) { return Number(a.id) - Number(b.id); });
*	var latestPostId = postFiles[postFiles.length - 1].id;

	var posts = Object.create(null);

*	postFiles.forEach(function(postFile) {
*		posts[postFile.id] = readPost(postFile.filename, postFile.type);
	});

and later (`id` is just renamed to `filename`)

*	function readPost(filename, type) {
*		var content = fs.readFileSync(__dirname + "/../posts/" + filename, "utf-8");
*		content = filter(content, type);
		var title = titleMatch ? titleMatch[1] : "no title";

Finally, `filter` is:

	function filter(post, type) {
		if (type == 'mk') {
			return mk(post);
		} else {
			return post;
		}
	}

We try it out by making `mk` showing the post in plain text, which requires a
function that escapes HTML:

	function escape(text) {
		return text
			.replace(/&/g, '&amp;')
			.replace(/</g, '&lt;')
			.replace(/>/g, '&gt;')
			.replace(/"/g, '&quot;')
			.replace(/'/g, '&#039;');
	}

	function mk(text) {
		return "<pre>" + escape(text) + "</pre>";
	}

Now, assuming that we have a file `posts/5.txt`, we should see its contents in
plain text by navigating to `http://localhost:3000/5`.

## Testing the markup engine

Markup engines are good candidates for unit testing.  In our spirit of
reinventing the wheel, we'll implement a simple unit testing framework.  We
create a file called `test` and write a simple function, `assert.is`, that
asserts that two values are the same.

	#!/usr/bin/env node

	assert = {
		is: function(lhs, rhs) {
			if (lhs !== rhs) {
				throw new Error('Got "' + lhs + '",\nExpected:  "' + rhs + '"');
			}
		}
	} 

To test it, try adding these lines to the `test` and running it (do `chmod +x
test` first):

	assert.is(1 + 2, 3);
	assert.is(1 + 2, 4);

You should get a stack trace telling which line is the faulty one, and what was
the expected value:

	% ./test 

	/Users/antti/work/blog/test:6
				throw new Error('Got "' + lhs + '",\nExpected:  "' + rhs + '"');
					  ^
	Error: Got "3",
	Expected:  "4"
		at Object.assert.is (/Users/antti/work/blog/test:6:10)
		at Object.<anonymous> (/Users/antti/work/blog/test:12:8)

Note how the actual and expected values are aligned on the same column so that
we can better compare differences between the two values -- this will prove
useful with strings containing newlines and whitespaces.  

Since our underlying JavaScript engine is V8, we can make the error message even
more useful.  For that we'll make use of structured stack traces that V8 gives
us, even if we have jump through a couple of hoops to get access to them:

First, instead of throwing an exception, we call `error` that handles
everything:

			if (lhs !== rhs) {
				error('Got "' + lhs + '",\nExpected:  "' + rhs + '"');
			}

`error` first prints out the error message, much like Node.js (actually, V8)
does by default:

	function error(msg) {
		console.log("Error: " + msg);

Next, it redefines `Error.prepareStackTrace` to make use of the V8's _structured
stack trace_ (http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi).  After
this function is in place, the `stack` property of any `Error` object will
contain the actual stack trace instead of a string value.  

We remove the first
two elements, since we don't want to see `error()` nor `assert.is()` in our
stack trace:

		Error.prepareStackTrace = function(e, stackTrace) {
			return stackTrace;
		};

We then create the `Error` object and take the first call site that interests
us from the stack.  (The topmost is in `error()` the next one in `assert.is()`
-- neither of which interests us.)

		var err = new Error();
		var callSite = err.stack[2];

The call site provides us with the file and line that caused the error.  We
slurp in its contents:

		var filename = callSite.getFileName();
		var file = require('fs').readFileSync(callSite.getFileName(), 'utf8');

We show the user the filename relative
(http://nodejs.org/api/path.html#path_path_relative_from_to) to the current
directory to reduce excess verbosity:

		var relative = require('path').relative(process.cwd(), filename);
		var line = callSite.getLineNumber();
		var column = callSite.getColumnNumber();

		console.log("\nFile: " + relative);
		console.log("Line: " + line);

The following extracts the line where the error happened and replaces tabs with
a single space.  This is necessary to pinpoint the exact location of the error,
since `callSite.getColumnNumber()` counts tabs as one character wide.

The other line draws a caret at the point where the error happened.  It lets us
to use the JavaScript trick `Array(n).join(' ')` to repeat a space character
`n-1` times.

		console.log("\n" + file.split('\n')[line-1].replace(/\t/g, ' '));
		console.log(Array(column).join(' ') + "^");

Lastly, we print the stack trace (starting from index 2) and exit.

		err.stack.splice(0, 2);
		console.log("\n" + err.stack.join('\n'));
		process.exit(1);
	}

The end result is now much more informative:

	% ./test
	Error: Got "3",
	Expected:  "4"

	File: test
	Line: 41

	assert.is(1 + 2, 4);
		   ^

	Object.<anonymous> (/Users/antti/work/blog/test:42:8)
	...

The `error` function is forced to reimplement much of the existing Node.js error
reporting code, since instead of the boring old `new Error(...)`, we wanted to
display code from a bit deeper in the call stack.  That's too bad, but now that
it's done, let's start testing.

## Tests, finally

We'll start writing (and testing) the markup engine in parts.  First, to ensure
that the tests are being run, we change `run.sh` to exercise the tests:

	export BLOG_ENV=dev

*	while ./test && ./server/run.js; do true; done

Running `run.sh` once reminds us to to to remove the failing assertion.

We then start to write the actual tests.  The first thing to do is to split the
file into parts separated by one or more blank newlines.  For that to work, we
need to first implement a `trim` function that deletes all whitespace from lines
that don't contain anything else and then removes leading and trailing newlines.

These tests test the `trim` function (which we'll expose as property of `mk`):

*	var mk = require('./lib/mk');
	
*	assert.is(mk.trim('a\n  \nb'), 'a\n\nb');
*	assert.is(mk.trim('foo\n  \n  bar  \n\t\nzot'), 'foo\n\n  bar  \n\nzot');
*	assert.is(mk.trim('\n\nfoo\n\n\n'), 'foo');
*	assert.is(mk.trim('one\n   \ntwo\t  \n \t\f\r\nthree \n\n '), 'one\n\ntwo\t  \n\nthree ');

The following regular expressions (in `lib/mk.js`) perform these feats:

*	function trim(text) {
*		var withoutBlankLines = text.replace(/\n[ \f\r\t\v]*$/gm, '\n');
*		var withoutStartingOrLeadingNewlines = 
*				withoutBlankLines.replace(/(^\n*)|(\n*$)/g, '');
*		return withoutStartingOrLeadingNewlines;
*	}

	...

*	module.exports.trim = trim;

(In the future, we'll export all tested functions like `trim` without mentioning
it explicitly.)

Next we might convert tabs to spaces using the `untabify` function.  This may
not be the most elegant nor the most efficient solution, but works well enough
to let us move on:

`test`:

	assert.is(mk.untabify('\t'), '    ');
	assert.is(mk.untabify(' \t'), '    ');
	assert.is(mk.untabify('  \t'), '    ');
	assert.is(mk.untabify('   \t'), '    ');
	assert.is(mk.untabify('    \t'), '        ');
	assert.is(mk.untabify('\tbar'), '    bar');
	assert.is(mk.untabify('*\tbar'), '*   bar');
	assert.is(mk.untabify(' *\t two'), ' *   two');
	assert.is(mk.untabify(' *\t\t three'), ' *       three');
	assert.is(mk.untabify('\t1\t2\n  \t\t zot\t'), '    1   2\n         zot    ');

`lib/mk.js`:

	function untabify(text) {
		result = '';
		column = 0;
		for (var i = 0, len = text.length; i < len; i++) {
			var c = text[i];
			if (c == '\t') {
				result += ' ';
				while (++column % 4 != 0) {
					result += ' ';
				}
				continue;
			} else if (c == '\n') {
				column = 0;
			} else {
				column++;
			}
			result += c;
		}
		return result;
	}

Then it's `split` time.  For testing it, we add `.eq` method to `assert` that
checks for deep equality, and then use it:

`test`:

	assert = {
		is: function(lhs, rhs) {
			...
*		},

*		eq: function(lhs, rhs) {
*			lhsS = JSON.stringify(lhs);
*			rhsS = JSON.stringify(rhs);
*			if (lhsS !== rhsS) {
*				error('"' + lhsS + '" is not "' + rhsS + '"');
*			}
*		}
	} 

	...

*	assert.eq(mk.split('one\ntwo\n\nthree\n\n\nfour'), ['one\ntwo', 'three', 'four']);

`split` breaks the paragraph (or similar top-level element) whenever it sees
two or more consecutive newlines:

	function split(text) {
		return text.split(/\n{2,}/);
	}

Now we have a list of top-level elements whose types we need to figure out:
paragraph, heading, raw html element, code block, unordered and ordered lists,
and blockquotes.

It's time to find out the type of a block.  First, the tests:

`test`:

	assert.is(mk.type('# foo'), 'heading');
	assert.is(mk.type(' # foo'), 'paragraph');
	assert.is(mk.type('###### foo'), 'heading');
	assert.is(mk.type('####### foo'), 'paragraph');
	assert.is(mk.type('    foo'), 'codeBlock');
	assert.is(mk.type('   foo'), 'paragraph');
	assert.is(mk.type('*   foo'), 'codeBlock');
	assert.is(mk.type('*  foo'), 'ul');
	assert.is(mk.type('* list'), 'ul');
	assert.is(mk.type('*list'), 'paragraph');
	assert.is(mk.type('#. list'), 'ol');
	assert.is(mk.type('#.list'), 'paragraph');
	assert.is(mk.type('> text'), 'blockquote');
	assert.is(mk.type('>text'), 'paragraph');
	assert.is(mk.type('<ins>text</ins>'), 'html');
	assert.is(mk.type(' <ins>text</ins>'), 'html');
	assert.is(mk.type('A <ins>text</ins>'), 'paragraph');
	assert.is(mk.type('* <ins>text</ins>'), 'ul');
	assert.is(mk.type('Hello world!'), 'paragraph');

Then, we'll implement `type`.  We find out that it's easiest to just look at the
first line -- we like to be as strict as possible to enforce consistent
formatting of the source file, but not at the expense of implementation
complexity.  Element types that are not recognized are assumed to be paragraphs. 

	function type(element) {
		if (/^#{1,6} /.test(element)) {
			return 'heading';
		} else if (/^    /.test(element)) {
			return 'codeBlock';
		} else if (/^\*   /.test(element)) {
			return 'codeBlock';
		} else if (/^\* /.test(element)) {
			return 'ul';
		} else if (/^\#\. /.test(element)) {
			return 'ol';
		} else if (/^> /.test(element)) {
			return 'blockquote';
		} else if (/^\s*</.test(element)) {
			return 'html';
		} else {
			return 'paragraph';
		}
	}

Then it's time to implement the handling of element types.  That is done by the
function `handle` (`lib/mk.js`):

	function handle(element) {
		return handlers[type(element)](element)
	}

	var handlers = {
		heading: function(element) { ... },
		codeBlock: function(element) { ... },
		ul: function(element) { ... },
		ol: function(element) { ... },
		html: function(element) { ... },
		blockquote: function(element) { ... },
		paragraph: function(element) { ... ]
	};

## Paragraphs

We'll start by implementing paragraphs, which are quite straightforward:

`test`:

		assert.is(mk.handle('This is a paragraph.'), '<p>This is a paragraph.');
		assert.is(mk.handle('A two-line\nparagraph.'), '<p>A two-line\nparagraph.');

`lib/mk.js`:

	paragraph: function(element) {
		return "<p>" + element;
	},

## Headings

	assert.is(mk.handle('# Title'), '<h1>Title</h1>');
	assert.is(mk.handle('###### Subsubsubsubsubtitle'), '<h6>Subsubsubsubsubtitle</h6>');
	assert.is(mk.handle('####### Subsubsubsubsubtitle'), '<p>####### Subsubsubsubsubtitle');

For now, the inline translations (italics, bold, links and inline code quotes)
are not performed.  We'll test and implement them later.

Headings are handled by simply wrapping the content inside a `<hN>` tag, where
`N` denotes the amount of `#`'s:

		heading: function(element) {
			var form = /^(#{1,6}) (.*)$/;
			var match = element.match(form);
			var level = match[1].length;
			var content = match[2];
			return "<h" + level + ">" + content + "</h" + level + ">";
		},

## Code blocks

	assert.is(mk.handle('    while (true)\n        repeat();'), '<pre><code>while (true)\n    repeat();</code></pre>');
	assert.is(mk.handle('    while (true)\n*       repeat();'), '<pre><code>while (true)\n<b>    repeat();</b></code></pre>');
	assert.is(mk.handle('    <!doctype html>\n    <html>&c.</html>'), '<pre><code>&lt;!doctype html&gt;\n&lt;html&gt;&amp;c.&lt;/html&gt;</code></pre>');

Code blocks require a bit more logic because we want to boldface the lines
beginning with `*`:

		codeBlock: function(element) {
			var lines = element.split('\n');
			function deindent(line) {
				var form = /^(\*| )   (.*)$/;
				var match = line.match(form);
				if (match[1] == '*') {
					return "<b>" + escape(match[2]) + "</b>";
				} else {
					return escape(match[2]);
				}
			}
			var content = lines.map(deindent).join('\n');

			return "<pre><code>" + content + "</code></pre>";
		},

## Lists

Ordered and unordered share the same structure and are relatively
straightforward to test and implement:

	assert.is(mk.handle('* foo\n* bar'), '<ul>\n<li>foo\n<li>bar\n</ul>');
	assert.is(mk.handle('#. foo\n#. bar'), '<ol>\n<li>foo\n<li>bar\n</ol>');

The implementation requires two helper functions that do the work:

	function li(item, prefix) {
		var content = item.replace(prefix, '');
		return "<li>" + content;
	}

	function list(type, prefix, element) {
		var result = "<" + type + ">\n";
		element.split('\n').forEach(function(item) {
			result += li(item, prefix) + '\n';
		});
		result += "</" + type + ">";
		return result;
	}

After that, the implementation is straightforward:

	ul: function(element) {
		return list("ul", /^\* /, element);
	},
	ol: function(element) {
		return list("ol", /^#. /, element);
	},

## HTML elements

HTML elements are passed as-is.  It seems silly to even test it.  We'll do it
anyway.

	assert.is(mk.handle('<hr>'), '<hr>');

and

	html: function(element) {
		return element;
	},

## Blockquotes

Blockquotes seem straightforward as well.  They simply strip their input of the
`> ` prefix and run it through `mk`, so things like multiple `<p>`s inside a
blockquote, blockquote inside a blockquote, etc. come to use easily.

	assert.is(mk.handle('> First line\n> another one.'), '<blockquote><p>First line\nanother one.</blockquote>');
	assert.is(mk.handle('> First paragraph\n> inside a blockquote.\n> \n> Second.'), '<blockquote><p>First paragraph\ninside a blockquote.\n<p>Second.\n</blockquote>');

But we still need to implement `mk` -- to do that, we use the building blocks we
have created and tested before.  `mk` preprocesses the text first with `trim`
and `untabify`, splits it into parts, handles each part separately, and finally
join them with newlines.

	function mk(text) {
*		var preprocessed = untabify(trim(text));
*		var parts = split(preprocessed);
*		var converted = parts.map(handle);
*		return converted.join('\n') + '\n';
	}

After that, we can implement `blockquote`:

	blockquote: function(element) {
		var stripped = element.replace(/^> /gm, '');
		return "<blockquote>" + mk(stripped) + "</blockquote>";
	}

## Inline elements
 
Now that the high-level structure is in place, we turn to look at the inline
elements.  That seem to be basically two environments to take care of: inside
`<code>` elements, where we want to escape pretty much everything, and
elsewhere (except inside HTML elements), where we want to translate our own
markup and escape HTML entities

(Or at least some of them: at this point it begins to fade to me that we need
to so some "smart" HTML recognition here; we want to escape the ampersand in
`Smith & Jones` but not the ampersand in `&copy;` and we want to escape the
inequality signs brackets in `if value < a but a > 0`, but not in `<a
href='#'>link text a</a>`.)

We forget this sidetrack for a moment and implement `filter` and `filterCode`
in `lib/mk.js` with straightforward ones:

	function filter(text) {
		return escape(text);
	}

	function filterCode(text) {
		return escape(text);
	}

We add some tests we expect to pass:

	assert.is(mk.filterCode("<h1 class='foo'>One & two</h1>"), "&lt;h1 class=&#039;foo&#039;&gt;One &amp; two&lt;/h1&gt;");
	assert.is(mk.filter('X & Y'), 'X &amp; Y');
	assert.is(mk.filter('a < b'), 'a &lt; b');

And others that won't pass yet, so we'll comment them out and revisit the
problem later:

	//assert.is(mk.filter('yes &ndash; no &amp; &'), 'yes &ndash; no &amp; &amp;');
	//assert.is(mk.filter("0 <a href='/get?x=1&y=2'>link</a>"), "0 <a href='/get?x=1&amp;y=2'>link</a>");

Then we'll start using `filter` and `filterCode` in the proper places (`lib/mk.js`:)

	function li(item, prefix) {
		var content = item.replace(prefix, '');
*		return "<li>" + filter(content);
	}

	...

	var handlers = {
		paragraph: function(element) {
*			return "<p>" + filter(element);
		},
		heading: function(element) {
			...
*			var content = filter(match[2]);
			return "<h" + level + ">" + content + "</h" + level + ">";
		},
		codeBlock: function(element) {
			...
				if (match[1] == '*') {
*					return "<b>" + filterCode(match[2]) + "</b>";
				} else {
*					return filterCode(match[2]);
				}

Next, we define functions for detecting and translating different kinds of
formatting:

	function codify(text) {
	}

	function italicize(text) {
	}

	function boldify(text) {
	}

	function linkify(text) {
	}

To implement `filter`, we expect these functions to be called in sequence.  But
let's first test them in separately:

	assert.is(mk.codify('a `span` of `<code>`'), 'a <code>span</code> of <code>&lt;code&gt;</code>');
	assert.is(mk.codify('`a && b << 2 + ""`'), '<code>a &amp;&amp; b &lt;&lt; 2 + &quot;&quot;</code>');

## Codify

To `codify`, we split the string into parts by `\`` and wrap every other part in
`<code>`:

	function codify(text) {
		var parts = text.split('`');
		return parts.map(function(part, i) {
			if (i % 2) {
				return '<code>' + filterCode(part) + '</code>';
			} else {
				return part;
			}
		}).join('');
	}

## Italicize

(Warning: this section is a bit heavy on regular expressions.  Take a deep
breath.)

To italicize, we must first decide how to an `/italic/` block can start and how
it can end.  We want the slashes to work outside words:

	assert.is(mk.italicize('Its /italic/.'), 'Its <i>italic</i>.');

We check that a sequence of italics work:

	assert.is(mk.italicize('/a/ /b/ /c/ /d/'), '<i>a</i> <i>b</i> <i>c</i> <i>d</i>');

Also inside parentheses (and outside, even though that's against the
typographical convention):

	assert.is(mk.italicize('(/This, too/.)'), '(<i>This, too</i>.)');
	assert.is(mk.italicize('/(This, too.)/'), '<i>(This, too.)</i>');

Slashes inside italicized blocks need to be allowed, and a standalone slash
should be inert:

	assert.is(mk.italicize('This is /A/B testing/!'), 'This is <i>A/B testing</i>!');
	assert.is(mk.italicize('This is not: and/or/something'), 'This is not: and/or/something');
	assert.is(mk.italicize('1 / 2 * 3 / 4 + /a / b / c/.'), '1 / 2 * 3 / 4 + <i>a / b / c</i>.');

Another test to check that it starting and ending slash works:

	assert.is(mk.italicize('/Italic/ starts, /in middle/, /ends/'), '<i>Italic</i> starts, <i>in middle</i>, <i>ends</i>');

It seems that what we want is to find a slash following something else than a
word character and then for a slash preceding something else than a word
character. 

Finding and replacing these one at a time with a regular expression will
probably get things done quickly and easily enough.  So let's start with that.

Since JavaScript regular expressions have the handy `\B` shorthand for matching
non-word boundaries, we'll use them:

	function italicize(text) {
		var pattern = /\B\/(.*)\/\B/g;
		return text.replace(pattern, '<i>$1</i>');
	}

This gets us through until `/a/ /b/ /c/ /d/`, which gets translated to `<i>a/
<i>b/ /c</i> /d</i>`.  Oops, we needed to use the _non-greedy matcher_
(https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Regular_Expressions#Using_Special_Characters)
to prevent the whole string from being matched at once:

		var pattern = /\B\/(.*?)\/\B/g;

This lets us through a couple of tests, but now we have the problem of at `1 / 2
* 3 / 4` turning into `1 <i> 2 * 3 </i> 4`.  So we'd like to prevent slashes
surrounded by white space to be not matched.  In fact, it's easier to follow a
simpler and stricter polict: a slash /followed/ by white space cannot be matched
(as the start slash).  This prevents `/ something/` from being matched, but then
again, if that /should/ be matched, why wouldn't ` / something/`?  Sometimes
strictness is just good.

We'll use a /negated lookahead/ pattern `(?!\s)` after the initial character
(which just means that match `/` only if not followed by `\s`:

		var pattern = /\B\/(?!\s)(.*?)\/\B/g;

The ending slash follows a similar rule in the other direction: white space may
not precede it.

		var pattern = /\B\/(?!\s)(.*?[^\s])\/\B/g;

As a side effect, `//` is not translated to `<i></i>` any more, since the
pattern now requires at least one (non-space) character in between the slashes.
We add that to the tests.

	assert.is(mk.italicize('A // comment?'), 'A // comment?');

Finally, all tests pass and we can give this minor monstrosity the permission to
get to work.  At least until some brave maintenance programmer comes digging.
(That might be sooner than expected; I suspect that the italicization might have
trouble with existing HTML end tags.)

## Boldify

## Linkify

## Tying it all together

TODO combining them all -- problems: 

* all make ending tags like (</code>) that cause problems with italicize

## Exercises 

* Make sure that the tests are run in production as well. Is this a good idea
to do during the deployment, or whenever the server is started?

* Test that `filter` and `filterCode` are used where they should be.

