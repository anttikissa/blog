# A markdown killer

In this post, we'll create an easier way to write the posts.

We might use a readymade markup language such as Markdown or Textile, but for
the sake of exercise we'll implement one ourselves.  It can't be that hard, can
it?

Our markup language will resemble Markdown closely.  Some features won't be
supported because HTML will do just fine (like horizontal rules, images, line
breaks); others we won't implement because they're not needed yet (like
nested lists); and some will look totally different because I think they should
look like they look in the browser (`/italics/`, `*bold*`, `_links_`); 

Unlike Markdown, which supports several different ways to emphasize text or to
write links, we'll just support a single way of doing things -- just to keep
things simple.

I expect the first version to be at least a bit buggy and missing some features
we will eventually require.  We'll revisit these shortcomings later.

## A wishlist for our markdown clone:

Paragraphs are separated by blank lines.  For simplicity, blank lines also
separate them from other elements, like lists, headings, and code blocks.

A line starting with `#`, `##`, etc. becomes a heading: `<h1>`, `<h2>`, etc.

HTML elements go through as-is (except when inside backtick quotes or code
blocks).  This includes top-level elements: a line starting with a HTML element
should start a top-level element, instead of being wrapped inside a `<p>`.

Backticks (`\``) create `<code>` elements, and backslashes (`\\`) quote
backticks, themselves, and other markup-specific characters.

The content in backticks and code blocks is escaped -- you can use `<` instead
of `&lt;` and `&` instead of `&amp;` and so on.  But elsewhere they are considered
raw HTML.  We may have to also escape elsewhere, as the `&` is often used in
body text, and mathematical text might make heavy use of `<` and `>`.  But let's
not do that yet.

Code blocks are indented with 4 spaces.  Tabs are converted 4 spaces.  There
will be no tabs in the resulting HTML.  They behave just like `<code>` elements,
except being wrapped inside a `<pre>`.  A `*` in the beginning of a code block
line wraps that line inside a `<b>`.

One or more words can be set `/in italics/` (which generates a `<i>` tag), or
`*in bold*` (which generates a `<b>` tag).

Links are presented `_like this_ (http://url.to/link)`.  (The reason for being
different from Markdown `[link text](link url)` is that I'm simply not
psychologically compatible with the Markdown syntax.  It's as if `[]` and `()`
somehow fall into the same category in my brain and I never get them in the
correct order.)

Unordered lists start with `* `.  Ordered lists start with `#. `.  We won't
support nested list items until we need them (which might be "never").

Blockquotes are prefixed by `> `.  The contents of the blockquote will be
stripped off the `> ` prefix and then run through the markup filter; so
preformatted `<code>` blocks, multiple paragraphs, and other markup elements are
formatted as they are formatted outside blockquotes.

TODO figure out a good syntax for commenting out lines. `#` won't do since it's
a heading at the start of line; what will? `//`?  Except inside code blocks?

Finally, to make it easier to write – and —, `--` is converted to
`&ndash;` and `---` to `&mdash;`.

## The first hints of modularity

We'll make Markdown Killer (the name of the markup language until someone comes
up with a better one) a module so it can be reused.  It goes to `lib/mk.js`:

	function mk(text) {
		// here goes the implementation
	}

	module.exports = mk;

In `server/run.js`, we use it:

	var fs = require('fs');
*	var mk = require('../lib/mk');
    
	var env = process.env.BLOG_ENV == 'dev' ? 'dev' : 'prod'

We decide to give the `.txt` extension to posts written in Markdown Killer, to
make it easier to tell them apart from raw HTML posts.  This requires some
changes in the code:

	var filenames = fs.readdirSync(__dirname + "/../posts");

*	var postFiles = filenames.filter(function(filename) {
*		return filename.match(/^\d+(\.txt)?$/);
*	}).map(function(filename) {
*		var match = filename.match(/^(\d+)(\.txt)?$/);
*		return {
*			id: match[1],
*			filename: filename,
*			type: match[2] == '.txt' ? 'mk' : 'html'
*		};
*	});

*	postFiles.sort(function(a, b) { return Number(a.id) - Number(b.id); });
*	var latestPostId = postFiles[postFiles.length - 1].id;

	var posts = Object.create(null);

*	postFiles.forEach(function(postFile) {
*		posts[postFile.id] = readPost(postFile.filename, postFile.type);
	});

and later (`id` is just renamed to `filename`)

*	function readPost(filename, type) {
*		var content = fs.readFileSync(__dirname + "/../posts/" + filename, "utf-8");
*		content = filter(content, type);
		var title = titleMatch ? titleMatch[1] : "no title";

Finally, `filter` is:

	function filter(post, type) {
		if (type == 'mk') {
			return mk(post);
		} else {
			return post;
		}
	}

We try it out by making `mk` showing the post in plain text, which requires a
function that escapes HTML:

	function escape(text) {
		return text
			.replace(/&/g, '&amp;')
			.replace(/</g, '&lt;')
			.replace(/>/g, '&gt;')
			.replace(/"/g, '&quot;')
			.replace(/'/g, '&#39;');
	}

	function mk(text) {
		return "<pre>" + escape(text) + "</pre>";
	}

Now, assuming that we have a file `posts/5.txt`, we should see its contents in
plain text by navigating to `http://localhost:3000/5`.

## Testing the markup engine

Markup engines are good candidates for unit testing.  In our spirit of
reinventing the wheel, we'll implement a simple unit testing framework.  We
create a file called `test` and write a simple function, `assert.is`, that
asserts that two values are the same.

	#!/usr/bin/env node

	assert = {
		is: function(lhs, rhs) {
			if (lhs !== rhs) {
				throw new Error('Got "' + lhs + '",\nExpected:  "' + rhs + '"');
			}
		}
	} 

To test it, try adding these lines to the `test` and running it (do `chmod +x
test` first):

	assert.is(1 + 2, 3);
	assert.is(1 + 2, 4);

You should get a stack trace telling which line is the faulty one, and what was
the expected value:

	% ./test 

	/Users/antti/work/blog/test:6
				throw new Error('Got "' + lhs + '",\nExpected:  "' + rhs + '"');
					  ^
	Error: Got "3",
	Expected:  "4"
		at Object.assert.is (/Users/antti/work/blog/test:6:10)
		at Object.<anonymous> (/Users/antti/work/blog/test:12:8)

Note how the actual and expected values are aligned on the same column so that
we can better compare differences between the two values -- this will prove
useful with strings containing newlines and whitespaces.  

Since our underlying JavaScript engine is V8, we can make the error message even
more useful.  For that we'll make use of structured stack traces that V8 gives
us, even if we have jump through a couple of hoops to get access to them:

First, instead of throwing an exception, we call `error` that handles
everything:

			if (lhs !== rhs) {
				error('Got "' + lhs + '",\nExpected:  "' + rhs + '"');
			}

`error` first prints out the error message, much like Node.js (actually, V8)
does by default:

	function error(msg) {
		console.log("Error: " + msg);

Next, it redefines `Error.prepareStackTrace` to make use of the V8's _structured
stack trace_ (http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi).  After
this function is in place, the `stack` property of any `Error` object will
contain the actual stack trace instead of a string value.  

We remove the first two elements, since we don't want to see `error()` nor
`assert.is()` in our stack trace:

		Error.prepareStackTrace = function(e, stackTrace) {
			return stackTrace;
		};

We then create the `Error` object and take the first call site that interests
us from the stack.  (The topmost is in `error()` the next one in `assert.is()`
-- neither of which interests us.)

		var err = new Error();
		var callSite = err.stack[2];

The call site provides us with the file and line that caused the error.  We
slurp in its contents:

		var filename = callSite.getFileName();
		var file = require('fs').readFileSync(callSite.getFileName(), 'utf8');

We show the user the filename _relative_
(http://nodejs.org/api/path.html#path_path_relative_from_to) to the current
directory to reduce excess verbosity:

		var relative = require('path').relative(process.cwd(), filename);
		var line = callSite.getLineNumber();
		var column = callSite.getColumnNumber();

		console.log("\nFile: " + relative);
		console.log("Line: " + line);

The following extracts the line where the error happened and replaces tabs with
a single space.  This is necessary to pinpoint the exact location of the error,
since `callSite.getColumnNumber()` counts tabs as one character wide.

The other line draws a caret at the point where the error happened.  It lets us
to use the JavaScript trick `Array(n).join(' ')` to repeat a space character
`n-1` times.

		console.log("\n" + file.split('\n')[line-1].replace(/\t/g, ' '));
		console.log(Array(column).join(' ') + "^");

Lastly, we print the stack trace (starting from index 2) and exit.

		err.stack.splice(0, 2);
		console.log("\n" + err.stack.join('\n'));
		process.exit(1);
	}

The end result is now much more informative:

	% ./test
	Error: Got "3",
	Expected:  "4"

	File: test
	Line: 41

	assert.is(1 + 2, 4);
		   ^

	Object.<anonymous> (/Users/antti/work/blog/test:42:8)
	...

The `error` function is forced to reimplement much of the existing Node.js error
reporting code, since instead of the boring old `new Error(...)`, we wanted to
display code from a bit deeper in the call stack.  That's too bad, but now that
it's done, let's start testing.

## Tests, finally

We'll start writing (and testing) the markup engine in parts.  First, to ensure
that the tests are being run, we change `run.sh` to exercise the tests:

	export BLOG_ENV=dev

*	while ./test && ./server/run.js; do true; done

Running `run.sh` once reminds us to to to remove the failing assertion.

We then start to write the actual tests.  The first thing to do is to split the
file into parts separated by one or more blank newlines.  For that to work, we
need to first implement a `trim` function that deletes all whitespace from lines
that don't contain anything else and then removes leading and trailing newlines.

These tests test the `trim` function (which we'll expose as property of `mk`):

	var mk = require('./lib/mk');
	
	assert.is(mk.trim('a\n  \nb'), 'a\n\nb');
	assert.is(mk.trim('foo\n  \n  bar  \n\t\nzot'), 'foo\n\n  bar  \n\nzot');
	assert.is(mk.trim('\n\nfoo\n\n\n'), 'foo');
	assert.is(mk.trim('one\n   \ntwo\t  \n \t\f\r\nthree \n\n '), 'one\n\ntwo\t  \n\nthree ');

The following regular expressions (in `lib/mk.js`) perform these feats:

	function trim(text) {
		var withoutBlankLines = text.replace(/\n[ \f\r\t\v]*$/gm, '\n');
		var withoutStartingOrLeadingNewlines = 
				withoutBlankLines.replace(/(^\n*)|(\n*$)/g, '');
		return withoutStartingOrLeadingNewlines;
	}

	...

	module.exports.trim = trim;

(In the future, we'll export all tested functions like `trim` without mentioning
it explicitly.)

Next we convert tabs to spaces using the `untabify` function.  This may not be
the most elegant nor the most efficient solution, but works well enough to let
us move on:

`test`:

	assert.is(mk.untabify('\t'), '    ');
	assert.is(mk.untabify(' \t'), '    ');
	assert.is(mk.untabify('  \t'), '    ');
	assert.is(mk.untabify('   \t'), '    ');
	assert.is(mk.untabify('    \t'), '        ');
	assert.is(mk.untabify('\tbar'), '    bar');
	assert.is(mk.untabify('*\tbar'), '*   bar');
	assert.is(mk.untabify(' *\t two'), ' *   two');
	assert.is(mk.untabify(' *\t\t three'), ' *       three');
	assert.is(mk.untabify('\t1\t2\n  \t\t zot\t'), '    1   2\n         zot    ');

`lib/mk.js`:

	function untabify(text) {
		result = '';
		column = 0;
		for (var i = 0, len = text.length; i < len; i++) {
			var c = text[i];
			if (c == '\t') {
				result += ' ';
				while (++column % 4 != 0) {
					result += ' ';
				}
				continue;
			} else if (c == '\n') {
				column = 0;
			} else {
				column++;
			}
			result += c;
		}
		return result;
	}

Then it's `split` time.  For testing it, we add `.eq` method to `assert` that
checks for deep equality, and then use it:

`test`:

	assert = {
		is: function(lhs, rhs) {
			...
*		},

*		eq: function(lhs, rhs) {
*			lhsS = JSON.stringify(lhs);
*			rhsS = JSON.stringify(rhs);
*			if (lhsS !== rhsS) {
*				error('"' + lhsS + '" is not "' + rhsS + '"');
*			}
*		}
	} 

	...

*	assert.eq(mk.split('one\ntwo\n\nthree\n\n\nfour'), ['one\ntwo', 'three', 'four']);

`split` breaks the paragraph (or similar top-level element) whenever it sees
two or more consecutive newlines:

	function split(text) {
		return text.split(/\n{2,}/);
	}

Now we have a list of top-level elements whose types we need to figure out:
paragraph, heading, raw html element, code block, unordered and ordered lists,
and blockquotes.

It's time to find out the type of a block.  First, the tests:

`test`:

	assert.is(mk.type('# foo'), 'heading');
	assert.is(mk.type(' # foo'), 'paragraph');
	assert.is(mk.type('###### foo'), 'heading');
	assert.is(mk.type('####### foo'), 'paragraph');
	assert.is(mk.type('    foo'), 'codeBlock');
	assert.is(mk.type('   foo'), 'paragraph');
	assert.is(mk.type('*   foo'), 'codeBlock');
	assert.is(mk.type('*  foo'), 'ul');
	assert.is(mk.type('* list'), 'ul');
	assert.is(mk.type('*list'), 'paragraph');
	assert.is(mk.type('#. list'), 'ol');
	assert.is(mk.type('#.list'), 'paragraph');
	assert.is(mk.type('> text'), 'blockquote');
	assert.is(mk.type('>text'), 'paragraph');
	assert.is(mk.type('<ins>text</ins>'), 'html');
	assert.is(mk.type(' <ins>text</ins>'), 'html');
	assert.is(mk.type('A <ins>text</ins>'), 'paragraph');
	assert.is(mk.type('* <ins>text</ins>'), 'ul');
	assert.is(mk.type('Hello world!'), 'paragraph');

Then, we'll implement `type`.  We find out that it's easiest to just look at the
first line -- we like to be as strict as possible to enforce consistent
formatting of the source file, but not at the expense of implementation
complexity.  Element types that are not recognized are assumed to be paragraphs. 

	function type(element) {
		if (/^#{1,6} /.test(element)) {
			return 'heading';
		} else if (/^    /.test(element)) {
			return 'codeBlock';
		} else if (/^\*   /.test(element)) {
			return 'codeBlock';
		} else if (/^\* /.test(element)) {
			return 'ul';
		} else if (/^\#\. /.test(element)) {
			return 'ol';
		} else if (/^> /.test(element)) {
			return 'blockquote';
		} else if (/^\s*</.test(element)) {
			return 'html';
		} else {
			return 'paragraph';
		}
	}

Then it's time to implement the handling of element types.  That is done by the
function `handle` (`lib/mk.js`):

	function handle(element) {
		return handlers[type(element)](element)
	}

	var handlers = {
		heading: function(element) { ... },
		codeBlock: function(element) { ... },
		ul: function(element) { ... },
		ol: function(element) { ... },
		html: function(element) { ... },
		blockquote: function(element) { ... },
		paragraph: function(element) { ... ]
	};

## Paragraphs

We'll start by implementing paragraphs, which are quite straightforward:

`test`:

		assert.is(mk.handle('This is a paragraph.'), '<p>This is a paragraph.');
		assert.is(mk.handle('A two-line\nparagraph.'), '<p>A two-line\nparagraph.');

`lib/mk.js`:

	paragraph: function(element) {
		return "<p>" + element;
	},

## Headings

	assert.is(mk.handle('# Title'), '<h1>Title</h1>');
	assert.is(mk.handle('###### Subsubsubsubsubtitle'), '<h6>Subsubsubsubsubtitle</h6>');
	assert.is(mk.handle('####### Subsubsubsubsubtitle'), '<p>####### Subsubsubsubsubtitle');

For now, the inline translations (italics, bold, links and inline code quotes)
are not performed.  We'll test and implement them later.

Headings are handled by simply wrapping the content inside a `<hN>` tag, where
`N` denotes the amount of `#`'s:

		heading: function(element) {
			var form = /^(#{1,6}) (.*)$/;
			var match = element.match(form);
			var level = match[1].length;
			var content = match[2];
			return "<h" + level + ">" + content + "</h" + level + ">";
		},

## Code blocks

	assert.is(mk.handle('    while (true)\n        repeat();'), '<pre><code>while (true)\n    repeat();</code></pre>');
	assert.is(mk.handle('    while (true)\n*       repeat();'), '<pre><code>while (true)\n<b>    repeat();</b></code></pre>');
	assert.is(mk.handle('    <!doctype html>\n    <html>&c.</html>'), '<pre><code>&lt;!doctype html&gt;\n&lt;html&gt;&amp;c.&lt;/html&gt;</code></pre>');

Code blocks require a bit more logic because we want to boldface the lines
beginning with `*`:

		codeBlock: function(element) {
			var lines = element.split('\n');
			function deindent(line) {
				var form = /^(\*| )   (.*)$/;
				var match = line.match(form);
				if (!match) {
					return escape(line);
				}
				if (match[1] == '*') {
					return "<b>" + escape(match[2]) + "</b>";
				} else {
					return escape(match[2]);
				}
			}
			var content = lines.map(deindent).join('\n');

			return "<pre><code>" + content + "</code></pre>";
		},

## Lists

Ordered and unordered share the same structure and are relatively
straightforward to test and implement:

	assert.is(mk.handle('* foo\n* bar'), '<ul>\n<li>foo\n<li>bar\n</ul>');
	assert.is(mk.handle('#. foo\n#. bar'), '<ol>\n<li>foo\n<li>bar\n</ol>');

The implementation requires two helper functions that do the work:

	function li(item, prefix) {
		var content = item.replace(prefix, '');
		return "<li>" + content;
	}

	function list(type, prefix, element) {
		var result = "<" + type + ">\n";
		element.split('\n').forEach(function(item) {
			result += li(item, prefix) + '\n';
		});
		result += "</" + type + ">";
		return result;
	}

After that, the implementation is straightforward:

	ul: function(element) {
		return list("ul", /^\* /, element);
	},
	ol: function(element) {
		return list("ol", /^#. /, element);
	},

## HTML elements

HTML elements are passed as-is.  It seems silly to even test it.  We'll do it
anyway.

	assert.is(mk.handle('<hr>'), '<hr>');

and

	html: function(element) {
		return element;
	},

## Blockquotes

Blockquotes seem straightforward as well.  They simply strip their input of the
`> ` prefix and run it through `mk`, so things like multiple `<p>`s inside a
blockquote, blockquote inside a blockquote, etc. come to use easily.

	assert.is(mk.handle('> First line\n> another one.'), '<blockquote><p>First line\nanother one.</blockquote>');
	assert.is(mk.handle('> First paragraph\n> inside a blockquote.\n> \n> Second.'), '<blockquote><p>First paragraph\ninside a blockquote.\n<p>Second.\n</blockquote>');

But we still need to implement `mk` -- to do that, we use the building blocks we
have created and tested before.  `mk` preprocesses the text first with `trim`
and `untabify`, splits it into parts, handles each part separately, and finally
join them with newlines.

	function mk(text) {
*		var preprocessed = untabify(trim(text));
*		var parts = split(preprocessed);
*		var converted = parts.map(handle);
*		return converted.join('\n') + '\n';
	}

After that, we can implement `blockquote`:

	blockquote: function(element) {
		var stripped = element.replace(/^> /gm, '');
		return "<blockquote>" + mk(stripped) + "</blockquote>";
	}

## Inline elements
 
Now that the high-level structure is in place, we turn to look at the inline
elements.  That seem to be basically two environments to take care of: inside
`<code>` elements, where we want to escape pretty much everything, and
elsewhere (except inside HTML elements), where we want to translate our own
markup and escape HTML entities

(Or at least some of them: at this point it begins to fade to me that we need
to so some "smart" HTML recognition here; we want to escape the ampersand in
`Smith & Jones` but not the ampersand in `&copy;` and we want to escape the
inequality signs brackets in `if value < a but a > 0`, but not in `<a
href='#'>link text a</a>`.)

We forget this sidetrack for a moment and implement `filter` and `filterCode`
in `lib/mk.js` with straightforward ones:

	function filter(text) {
		return escape(text);
	}

	function filterCode(text) {
		return escape(text);
	}

We add some tests we expect to pass:

	assert.is(mk.filterCode("<h1 class='foo'>One & two</h1>"), "&lt;h1 class=&#39;foo&#39;&gt;One &amp; two&lt;/h1&gt;");
	assert.is(mk.filter('X & Y'), 'X &amp; Y');
	assert.is(mk.filter('a < b'), 'a &lt; b');

And others that won't pass yet, so we'll comment them out and revisit the
problem later:

	//assert.is(mk.filter('yes &ndash; no &amp; &'), 'yes &ndash; no &amp; &amp;');
	//assert.is(mk.filter("0 <a href='/get?x=1&y=2'>link</a>"), "0 <a href='/get?x=1&amp;y=2'>link</a>");

Then we'll start using `filter` and `filterCode` in the proper places (`lib/mk.js`:)

	function li(item, prefix) {
		var content = item.replace(prefix, '');
*		return "<li>" + filter(content);
	}

	...

	var handlers = {
		paragraph: function(element) {
*			return "<p>" + filter(element);
		},
		heading: function(element) {
			...
*			var content = filter(match[2]);
			return "<h" + level + ">" + content + "</h" + level + ">";
		},
		codeBlock: function(element) {
			...
				if (!match) {
*					return filterCode(line);
				}
				if (match[1] == '*') {
*					return "<b>" + filterCode(match[2]) + "</b>";
				} else {
*					return filterCode(match[2]);
				}

Next, we define functions for detecting and translating different kinds of
formatting:

	function codify(text) {
	}

	function italicize(text) {
	}

	function boldify(text) {
	}

	function linkify(text) {
	}

To implement `filter`, we expect these functions to be called in sequence.  The
sequence I'm thinking about is `codify` -> `italicize` -> `boldify` ->
`linkify`:  I figure that `codify` needs to come first so that the slashes,
asterisks, and underscores inside code blocks won't be translated.  The order of
`italicize`, `boldify` and `linkify` is pretty much arbitrary.  If we run into
trouble with this order, we'll deal with it at that time.

But let's first test them in separately.

## Codify

	assert.is(mk.codify('a `span` of `<code>`'), 'a <code>span</code> of <code>&lt;code&gt;</code>');
	assert.is(mk.codify('`a && b << 2 + ""`'), '<code>a &amp;&amp; b &lt;&lt; 2 + &quot;&quot;</code>');

To `codify`, we split the string into parts by `\`` and wrap every other part in
`<code>`:

	function codify(text) {
		var parts = text.split('`');
		return parts.map(function(part, i) {
			if (i % 2) {
				return '<code>' + filterCode(part) + '</code>';
			} else {
				return part;
			}
		}).join('');
	}

To protect the special characters inside `<code>` blocks from being translated
in the later phases, we need to quote them in `filterCode`:

	assert.is(mk.codify('`/italic/ and *bold* and _link to_ (foo.html)`'), '<code>&sol;italic&sol; and &ast;bold&ast; and &lowbar;link to&lowbar; (foo.html)</code>');

`filterCode` wants to avoid quoting the slashes that are part of HTML closing tags (since that produces unreadable code.  So we modify the normal escaping sequence a bit:

	function filterCode(text) {
		return text
			.replace(/&/g, '&amp;')
			.replace(/(^|[^<])\//g, '$1&sol;')
			.replace(/</g, '&lt;')
			.replace(/>/g, '&gt;')
			.replace(/"/g, '&quot;')
			.replace(/'/g, '&#39;')
			.replace(/\*/g, '&ast;')
			.replace(/_/g, '&lowbar;');
	}

(Note that we must place the handling of `/` between `&` and `<` for it to work
correctly.  The rest can come at the end.)

At this point we also realize that it is useful escape the non-`code` parts in
`codify` as well, since we have it already in our hands:

	function codify(text) {
		var parts = text.split('`');
		return parts.map(function(part, i) {
			if (i % 2) {
				return '<code>' + filterCode(part) + '</code>';
			} else {
*				return escape(part);
			}
		}).join('');
	}

We add a test for this as well:

	assert.is(mk.codify('`/foo_bar/ & 1` looks like /foo_bar/ & 1'), '<code>&sol;foo&lowbar;bar&sol; &amp; 1</code> looks like /foo_bar/ &amp; 1');

The only thing still missing of `codify` is the quoting of backticks (and
slashes); we'll revisit that later.

## Italicize

(Warning: this section is a bit heavy on regular expressions.  And it's just a
prelude to what's coming later when we get to URL matching.)

To italicize, we must first decide how an `/italic/` block can start and how
it can end.  We want the slashes to work outside words:

	assert.is(mk.italicize('Its /italic/.'), 'Its <i>italic</i>.');

We check that a sequence of italics work:

	assert.is(mk.italicize('/a/ /b/ /c/ /d/'), '<i>a</i> <i>b</i> <i>c</i> <i>d</i>');

Also inside parentheses (and outside, even though that's against the
typographical convention):

	assert.is(mk.italicize('(/This, too/.)'), '(<i>This, too</i>.)');
	assert.is(mk.italicize('/(This, too.)/'), '<i>(This, too.)</i>');

Slashes inside italicized blocks need to be allowed, and a standalone slash
should be inert:

	assert.is(mk.italicize('This is /A/B testing/!'), 'This is <i>A/B testing</i>!');
	assert.is(mk.italicize('This is not: and/or/something'), 'This is not: and/or/something');
	assert.is(mk.italicize('1 / 2 * 3 / 4 + /a / b / c/.'), '1 / 2 * 3 / 4 + <i>a / b / c</i>.');

Another test to check that it starting and ending slash works:

	assert.is(mk.italicize('/Italic/ starts, /in middle/, /ends/'), '<i>Italic</i> starts, <i>in middle</i>, <i>ends</i>');

It seems that what we want is to find a slash following something else than a
word character and then for a slash preceding something else than a word
character. 

Finding and replacing these with a regular expression will probably get things
done quickly and easily enough.  So let's start with that.

Since JavaScript regular expressions have the handy `\B` shorthand for matching
non-word boundaries, we'll use them:

	function italicize(text) {
		var pattern = /\B\/(.*)\/\B/g;
		return text.replace(pattern, '<i>$1</i>');
	}

We could also match a non-word character `\W` directly, but then we'd have to
also handle the case when the starts or ends with a `/`.  `\B` handles that case
as well (string boundaries are considered non-word characters).

This gets us through until `/a/ /b/ /c/ /d/`, which gets translated to `<i>a/
<i>b/ /c</i> /d</i>`.  Oops, we needed to use the _non-greedy matcher_
(https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Regular_Expressions#Using_Special_Characters)
to prevent the whole string from being matched at once:

		var pattern = /\B\/(.*?)\/\B/g;

This lets us through a couple of tests, but now we have the problem of at `1 / 2
* 3 / 4` turning into `1 <i> 2 * 3 </i> 4`.  So we'd like to prevent slashes
surrounded by white space to be not matched.  In fact, it's easier to follow a
simpler and stricter policy: a slash /followed/ by white space cannot be matched
(as the start slash).  This prevents `/ something/` from being matched, but then
again, if that /should/ be matched, why wouldn't ` / something/`?  Sometimes
strictness is just good.

We'll use a /negated lookahead/ pattern `(?!\s)` after the initial character
(which just means that match `/` only if not followed by `\s`:

		var pattern = /\B\/(?!\s)(.*?)\/\B/g;

The ending slash follows a similar rule in the other direction: white space may
not precede it.

		var pattern = /\B\/(?!\s)(.*?[^\s])\/\B/g;

As a side effect, `//` is not translated to `<i></i>` any more, since the
pattern now requires at least one (non-space) character in between the slashes.
We add that to the tests.

	assert.is(mk.italicize('A // comment?'), 'A // comment?');

Do we support newlines?

	assert.is(mk.italicize("across /the\nnewline/, too"), "across <i>the\nnewline</i>, too");

Whoops, we do not: let's replace `.` with `[^]` that also matches newlines.

		var pattern = /\B\/(?!\s)([^]*?[^\s])\/\B/g;

There are still (at least) two special cases we need to consider: end tags such
as `</code>` and urls such as `http://foo.com`.  It's easiest not to try to do
encode that logic into the regular expression and do the check in code instead:

		var pattern = /\B\/(?!\s)([^]*?[^\s])\/\B/g;
*		return text.replace(pattern, function(match, p1, offset) {
*			if (offset > 0 && text[offset-1] == '<') {
*				return match;
*			}
*			if (offset > 1 && text[offset-2] == ':' && text[offset-1] == '/') {
*				return match;
*			}
			return '<i>' + p1 + '</i>';
		});

TODO actually it's not. `some code \`foo\` /italics/ doesn't work.`

Test: /italics/ `foo` /italics/

Now all tests pass and we can give this minor monstrosity the permission to
get to work.  At least until some brave maintenance programmer comes digging.
(That might be sooner than expected; I suspect that the italicization might have
trouble with existing HTML end tags.)

## Boldify

To make things that look `*like this*` bold, i.e. wrapping them inside `<b>`
tags, we do almost exactly the same as with `italicize`.

We write a couple of tests:

	assert.is(mk.boldify('*this is bold*'), '<b>this is bold</b>');
	assert.is(mk.boldify('*this* *too* *is*'), '<b>this</b> <b>too</b> <b>is</b>');
	assert.is(mk.boldify('*multiple words*'), '<b>multiple words</b>');
	assert.is(mk.boldify('inside *a sentence* works'), 'inside <b>a sentence</b> works');

	assert.is(mk.boldify('but 2 * 3 * 4 is not *bold*'), 'but 2 * 3 * 4 is not <b>bold</b>');
	assert.is(mk.boldify('nor is a*b*c nor a*b* nor *a*b'), 'nor is a*b*c nor a*b* nor *a*b');

and take `italicize` and replace slashes with asterisks: 

	function boldify(text) {
		var pattern = /\B\*(?!\s)([^]*?[^\s])\*\B/g;
		return text.replace(pattern, '<b>$1</b>');
	}

The tests pass; we are ready to move on, but not before noting a corner case
that might warrant our attention: what happens if the user writes overlapping
codes like `*this _sentence is* invalid_`?  A more robust markup language might
do some error handling, but we don't -- instead we generate invalid HTML
independent of the order of `boldify` and `italicize`.  If the user wants to
shoot herself in the foot, let her do it.

	assert.is(mk.boldify(mk.italicize('*this /sentence is* invalid/')), '<b>this <i>sentence is</b> invalid</i>');

	assert.is(mk.italicize(mk.boldify('*this /sentence is* invalid/')), '<b>this <i>sentence is</b> invalid</i>');

## Linkify

A link is an underlined sequence of text, followed by whitespace and
parentheses.  
We'll start with a special case: a link without an URL.  Since HTML5 allows
/placeholder URLs/ without a `href`, we'll generate those:

	assert.is(mk.linkify('_previous_ and _next_'), '<a>previous</a> and <a>next</a>');

And the function to recognize this is easily derived from the earlier ones: we
only have to switch `\B` to `\b` since underscore is a word character.

	function linkify(text) {
		var pattern = /\b_(?!\s)([^]*?[^\s])_\b/g;
		return text.replace(pattern, '<a>$1</a>');
	}

Then we add support for the URL:

	assert.is(mk.linkify('_Google_ (http://google.com/)'), "<a href='http://google.com/'>Google</a>");

And for extra points make sure that the URL is quoted properly:

	assert.is(mk.linkify("_Google_ (http://google.com/?q=foo&x='abc')"), "<a href='http://google.com/?q=foo&amp;x=&#39;abc&#39;'>Google</a>");

To satisfy these tests, the new `linkify` looks like:

	function linkify(text) {
*		var pattern = /\b_(?!\s)(.*?[^\s])_(?:\s*\((.*?)\)|\b)/g;
*		return text.replace(pattern, function(match, p1, p2) {
*			var href = p2 ? " href='" + escape(p2)+ "'" : "";
*			return '<a' + href + '>' + p1 + '</a>';
*		});
	}

The regular expression is augmented to alternatively accept white space followed
by a parenthesized URL.  Only the relevant parts of the pattern, the URL and the
link text, are captured, and for the alternative form we use our old friend, the
non-capturing parentheses `(?:x)`.  We use a non-greedy match for the URL to
avoid capturing too much by accident.

We need to a different form of the `replace` function that takes a function and
invokes it for each match.  We then perform the necessary translation and return
the desired result.

The tests pass, but what about URLs that contain parentheses?  These are
relatively common in URLs like
`http://en.wikipedia.org/wiki/Bracket_(mathematics)`.  Let's add some of these
to our test cases:

	assert.is(mk.linkify("_A (band)_ (http://en.wikipedia.org/wiki/A_(band))"), "<a href='http://en.wikipedia.org/wiki/A_(band)'>A (band)</a>");
	assert.is(mk.linkify("_Law (band)_ (http://en.wikipedia.org/wiki/Law_(band)_(disambiguation))"), 
	assert.is(mk.linkify("_Hypothetical URL_ (http://eval.com/(+ 1 (+ 2 3))"), 

Unfortunately, the power of regular expressions does not let us match an
arbitrary number of symmetrical parentheses.  But we can do it for a given
amount of nested parentheses.  This will get a complicated, again, so we'll
develop the nested parentheses part separately.  

Since angle brackets `<>` are much easier to read in regular expressions than
the usual ones that must be escaped, we'll use them during construction and then
replace them with `\(` and `\)`.

We'll do this construction by writing the regular expression in the `test` file
and doing assertions directly there.

To read a matching pair of angle brackets with no brackets inside, we need to
make sure to use the non-matching repeater:

	var bracketMatcher = function(string) {
		var pattern = /<(.*?)>/;
		var match = string.match(pattern);
		return match ? match[1] : null;
	}

This ensures that basic cases like

	assert.is(bracketMatcher('<hello>'), 'hello');
	assert.is(bracketMatcher('a <b> c'), 'b');
	assert.is(bracketMatcher('a <first> <second> c'), 'first');

work; but if we want to be strict about the insides of the bracket (we'll soon
see why), we'll want to avoid matching nested brackets:

	assert.is(bracketMatcher('<less <than>'), '<than>');

For this to pass, we'll extend our pattern to only match non-bracket characters
inside brackets.

		var pattern = /<([^<>]*)>/;

Next we want to match nested brackets:

	assert.is(bracketMatcher('<a <b> c>'), 'a <b> c');

Since that's just "anything followed by bracketed expression followed by
anything," let's write that down as a regular expression.  Assuming "anything"
means "anything that is not a bracket."

		var pattern = /<([^<>]*<[^<>]*>[^<>]*)>/;

While this would work for the latest test, the first test cases fail; we need to
make the inner brackets optional, so our match is now "anything followed by an
optional bracketed expression followed by anything":

		var pattern = /<([^<>]*(?:<[^<>]*>)?[^<>]*)>/;

To support multiple brackets, this not enough:

	assert.is(bracketMatcher('<a <b> and <c> d>'), 'a <b> and <c> d');

We realize it actually needs to be "(anything followed by bracketed expression)
any number of times, followed by anything", where any number of times includes
zero.

		var pattern = /<((?:[^<>]*<[^<>]*>)*[^<>]*)>/;

Now to support two levels of nesting,

	assert.is(bracketMatcher('<a <b <c> <d> e> and <f <g> h> i>'), 'a <b <c> <d> e> and <f <g> h> i');

, we replace the `[^<>]*` inside the innermost brackets with the thing that
represents "(anything followed by bracketed expression) any number of times,
followed by anything", that is, `(?:[^<>]*<[^<>]*>)*[^<>]*`, and get the
following:

	assert.is(bracketMatcher('<a <b <c> <d> e> and <f <g> h> i>'), 'a <b <c> <d> e> and <f <g> h> i');

To make that it works with strange corner cases and counts the brackets right to
two levels of nesting, we still do some more testing:

	assert.is(bracketMatcher('<<<>>>'), '<<>>');
	assert.is(bracketMatcher('<<<<>>>>'), '<<>>');
	assert.is(bracketMatcher('<<<<><><>>>>'), '<<><><>>');
	assert.is(bracketMatcher('<foo<bar>>>>'), 'foo<bar>');
	assert.is(bracketMatcher('<<<<foo<bar>>'), 'foo<bar>');
	assert.is(bracketMatcher('<4<3<2<1'), null);
	assert.is(bracketMatcher('<4<3<2<1>'), '1');
	assert.is(bracketMatcher('<4<3<2<1>>'), '2<1>');
	assert.is(bracketMatcher('<4<3<2<1>>>'), '3<2<1>>');
	assert.is(bracketMatcher('<4<3<2<1>>>>'), '3<2<1>>');

The last one also documents the limits of the matcher.

Now we can take a deep breath, take the abomination we just created, replace
brackets with quoted parentheses, and replace the parentheses-matching part of
the URL matcher with that.

	var pattern = /\b_(?!\s)(.*?[^\s])_(?:\s*\(((?:[^\(\)]*\((?:[^\(\)]*\([^\(\)]*\))*[^\(\)]*\))*[^\(\)]*)\)|\b)/g;

With that, the URL with two levels of parentheses is matched correctly, but
three levels fails:

	assert.is(mk.linkify("_This fails_ (http://eval.com/(+ 1 (+ 2 (+ 3 4))))"), "<a>This fails</a> (http://eval.com/(+ 1 (+ 2 (+ 3 4))))");

We'll live with that restriction (at least until we decide to use some other
technology than regular expressions to do the matching).

## Finish the unfinished

We note that code blocks that have blank lines in the middle get split up (even
if they're indented with 4 spaces).  Understandable, given that the first thing
we do is run `trim` to blank out all whitespace-only lines, and then use `\n\n`
as a separator.  To make up for this, we join consecutive code blocks after
splitting:

	function mk(text) {
		var preprocessed = untabify(trim(text));
		var parts = split(preprocessed);
*		parts = joinCodeBlocks(parts);
		var converted = parts.map(handle);
		return converted.join('\n') + '\n';
	}

`joinCodeBlocks` looks like:

	function joinCodeBlocks(parts) {
		var result = [];
		for (var i = 0, len = parts.length; i < len; i++) {
			var part = parts[i];
			if (result.length) {
				if (type(part) == 'codeBlock') {
				}
				prevIdx = result.length - 1;
				if (type(part) == 'codeBlock' && type(result[prevIdx]) == 'codeBlock') {
					result[prevIdx] += '\n    \n' + part;
					continue;
				} 
			}
			result.push(part);
		}
		return result;
	}

and a test for that:

	assert.is(mk("    int x;\n    \n    x = 1;"), "<pre><code>int x;\n\nx = 1;</code></pre>\n");

Another problem is that we can't yet quote backticks `\`` inside `<code>`
expressions.  We'll need to change the approach for processing them.  Armed with
a newly found enthusiasm for regular expressions, we decide to use them.  We'll
first rewrite the current `codify`:

	function codify(text) {
		var pattern = /`([^`]*)`/g;
		var codeBlocksEscaped = text.replace(pattern, function(match, p1) {
			return '<code>' + filterCode(p1) + '</code>';
		});

		var restPattern = /(^|<\/code>)(.*?)(<code>|$)/g;
		return codeBlocksEscaped.replace(restPattern, function(match, p1, p2, p3) {
			return p1 + escape(p2) + p3;
		});
	}

It first takes apart blocks surrounded by backticks and wraps them in `<code>`
tags.  Then it processes the text outside the code blocks, making sure that the
non-greedy matcher is used so that it won't accidentally escape a code block
twice.  We trust that it works, since the tests pass, and write some tests that
will fail:

	assert.is(mk('`\\``'), '<code>`</code>');
	assert.is(mk('`\\`` `\\\\` `\\\\\\``'), '<code>`</code> <code>\\</code> <code>\\`</code>');

We first implement the quoting part in `filterCode`: we just replace `\\`
followed by a character with that character:

			.replace(/\*/g, '&ast;')
			.replace(/_/g, '&lowbar;')
*			.replace(/\\(.)/g, '$1');
}

Next we change `codify` so it doesn't consume the combination `\\\``:

		var pattern = /`([^\\`]*(?:\\.[^`\\]*)*)`/g;

Inside the outermost `\``s, we first read a string containing neither `\\`s nor
`\``s.  When we encounter a `\\` followed by a character that it quotes, we
consume it and the following a string that doesn't have `\``s or `\\`; and this
we do N times, until we find the terminating `\``.  And so, quoting inside
`<code>` blocks works.

Quoting will be useful also outside code elements:

	assert.is(mk('A \\` outside a code block'), "A ` outside a code block");

This necessitates a change in `codify`, again:

	var pattern = /([^\\]|^)`([^\\`]*(?:\\.[^`\\]*)*)`/g;

	var codeBlocksEscaped = text.replace(pattern, function(match, p1, p2) {
		return p1 + '<code>' + filterCode(p2) + '</code>';
	});

Now it needs a non-backslash character (or the beginning of string) in front of
it.  It will be inserted in front of the generated code block.

## Quoting HTML...

Does this *work*? This &ndash; is <span style='color: green'>green</span>.

How about this? *Inside /this/ outside*.  Or /this *inside* outside/.

## Conclusion

At the end, while it seems to work, it's not very well performing, and probably
still bug-ridden, but at least we have a test suite.  There are only so many
bugs that can fit inside one markup language implementation, and the amount of
new bugs introduced by fixing one bug is still much less than one, so eventually
our implementation will converge to a more or less bug-free one.

## Exercises 

* Make sure that the tests are run in production as well. Is this a good idea
to do during the deployment, or whenever the server is started?

* Test that `filter` and `filterCode` are used where they should be.

* Make it possible to escape `*`, `_`, `(`, `)` and `/` outside `<code>`
elements.

